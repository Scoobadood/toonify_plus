//
// Created by Dave Durbin (Old) on 19/7/21.
//

#pragma once

const std::string VERTEX_SHADER_SRC =
        "#version 410 core\n"
        "layout (location = 0) in vec3 a_vertex_data;\n"
        "layout (location = 1) in vec3 a_vertex_colour;\n"
        "layout (location = 2) in vec2 a_texture_coordinate;\n"
        "out vec3 vertex_colour;\n"
        "out vec2 texture_coordinate;\n"
        "void main()\n"
        "{\n"
        "   vertex_colour = a_vertex_colour;\n"
        "   texture_coordinate = a_texture_coordinate;\n"
        "   gl_Position = vec4(a_vertex_data.x, a_vertex_data.y, a_vertex_data.z, 1.0);\n"
        "}";

const std::string DUMMY_FRAG_SHADER =
    "#version 410 core\n"
    "out vec4 FragColor;\n"
    "uniform sampler2D source_texture;\n"
    "in vec3 vertex_colour;\n"
    "in vec2 texture_coordinate;\n"
    "void main() {\n"
    "  FragColor = texture(source_texture, texture_coordinate);\n"
    "}";

const std::string LUM_QUANT_FRAG_SHADER_SRC =
        "#version 410 core\n"
        "/*\n"
        " * Luminance quantization\n"
        " */\n"
        "uniform sampler2D u_input_image;\n"
        "uniform      vec2 u_image_resolution;\n"
        "uniform     float u_bin_width;\n"
        "uniform     float u_psi_q;\n"
        "out          vec4 fragment_colour;\n"
        "/**\n"
        " * Convert frag_coord (image space) to textureCoord.\n"
        " */\n"
        "vec2 frag_to_texture(in vec2 frag_coord) {\n"
        "  return frag_coord / u_image_resolution;\n"
        "}\n"
        "/**\n"
        " * Extract image value of pixel relative to this one.\n"
        " * @param dx The x offset\n"
        " * @param dy The y offset\n"
        " * @return The greyscale value. Computed as mean of RGB\n"
        " */\n"
        "vec4 image_colour_at(in vec2 frag_coord, in int dx, in int dy) {\n"
        "  vec2 tex_coord = frag_to_texture(frag_coord\n"
        "                    + vec2(float(dx), float(dy)));\n"
        "  return texture(u_input_image, tex_coord);\n"
        "}\n"
        "/**\n"
        " * Approximate tanh\n"
        " */\n"
        "float tanh(in float value) {\n"
        "  float v2 = value * value;\n"
        "  float r1 = (v2 / 11.0) + 9.0;\n"
        "  float r2 = (v2 / r1 ) + 7.0;\n"
        "  float r3 = (v2 / r2 ) + 5.0;\n"
        "  float r4 = (v2 / r3 ) + 3.0;\n"
        "  float r5 = (v2 / r4 ) + 1.0;\n"
        "  return value / r5;\n"
        "}\n"
        "vec4 quantize_colour( in vec2 coord ) {\n"
        "  vec4 colour = image_colour_at(coord, 0, 0);\n"
        "  float q_nearest = colour.x / u_bin_width;\n"
        "  q_nearest = floor(q_nearest + 0.5) * u_bin_width;\n"
        "  float luminance = q_nearest\n"
        "                    + (u_bin_width / 2.0)\n"
        "                    * tanh(u_psi_q * ( colour.x - q_nearest));\n"
        "  return vec4( luminance, colour.y, colour.z, 1.0);\n"
        "}\n"
        "void main() {\n"
        "  fragment_colour = quantize_colour(gl_FragCoord.xy);\n"
        "}";

const std::string RGB_SWAPPER_FRAG_SHADER =
        "#version 410 core\n"
        "/*\n"
        " * RGB Swapper\n"
        " */\n"
        "uniform sampler2D u_input_image;\n"
        "uniform      vec2 u_image_resolution;\n"
        "out          vec4 fragment_colour;\n"
        "/**\n"
        " * Convert frag_coord (image space) to textureCoord.\n"
        " */\n"
        "vec2 frag_to_texture(in vec2 frag_coord) {\n"
        "  return frag_coord / u_image_resolution;\n"
        "}\n"
        "/**\n"
        " * Extract image value of pixel relative to this one.\n"
        " * @param dx The x offset\n"
        " * @param dy The y offset\n"
        " * @return The greyscale value. Computed as mean of RGB\n"
        " */\n"
        "vec4 image_colour_at(in vec2 frag_coord, in int dx, in int dy) {\n"
        "  vec2 tex_coord = frag_to_texture(frag_coord\n"
        "                    + vec2(float(dx), float(dy)));\n"
        "  return texture(u_input_image, tex_coord);\n"
        "}\n"
        "/**\n"
        " * Approximate tanh\n"
        " */\n"
        "float tanh(in float value) {\n"
        "  float v2 = value * value;\n"
        "  float r1 = (v2 / 11.0) + 9.0;\n"
        "  float r2 = (v2 / r1 ) + 7.0;\n"
        "  float r3 = (v2 / r2 ) + 5.0;\n"
        "  float r4 = (v2 / r3 ) + 3.0;\n"
        "  float r5 = (v2 / r4 ) + 1.0;\n"
        "  return value / r5;\n"
        "}\n"
        "vec4 quantize_colour( in vec2 coord ) {\n"
        "  vec4 colour = image_colour_at(coord, 0, 0);\n"
        "  float q_nearest = colour.x / u_bin_width;\n"
        "  q_nearest = floor(q_nearest + 0.5) * u_bin_width;\n"
        "  float luminance = q_nearest\n"
        "                    + (u_bin_width / 2.0)\n"
        "                    * tanh(u_psi_q * ( colour.x - q_nearest));\n"
        "  return vec4( luminance, colour.y, colour.z, 1.0);\n"
        "}\n"
        "void main() {\n"
        "  fragment_colour = quantize_colour(gl_FragCoord.xy);\n"
        "}";